{
    "Introduction": {
        "content": "Even when data integrated from multiple sources refer to the same real-world entities (e.g., persons, places), they usually exhibit several quality issues such as incompleteness (i.e., partial data), redundancy (i.e., overlapping data), inconsistency (i.e., conflicting data) or simply incorrectness (i.e., data errors). A typical task for improving various data quality aspects is Entity Resolution (ER). In the Web of Data, ER aims to facilitate interlinking of data that describe the same real-world entity, when unique entity identifiers are not shared across different Knowledge Bases (KBs) describing them [8]. To resolve entity descriptions we need (a) to compute effectively the similarity of entities, and (b) to pair-wise compare entity descriptions. Both problems are challenged by the three Vs of the Web of Data, namely Variety, Volume and Veracity [10]. Not only does the number of entity descriptions published by each KB never cease to increase, but also the number of KBs even for a single domain, has grown to thousands (e.g., there is a x 100 growth of the LOD cloud size since its first edition ${ }^{1}$ ). Even in the same domain, KBs are extremely heterogeneous both regarding how they semantically structure their data, as well as\n\n[^0]\n",
        "title": [
            "## 1 INTRODUCTION"
        ],
        "summary": "This section discusses the challenges of integrating data from multiple sources, particularly focusing on issues like incompleteness, redundancy, inconsistency, and errors in entity descriptions. It highlights Entity Resolution (ER) as a crucial process for improving data quality by matching and interlinking records that refer to the same real-world entities, especially when unique identifiers are lacking across diverse Knowledge Bases (KBs). The section emphasizes that the effectiveness of ER is hindered by the increasing variety, volume, and veracity of data on the Web, as well as by the growing heterogeneity and number of KBs, even within single domains."
    },
    "Problem Definition": {
        "content": "Given a KB $\\mathcal{E}$, an entity description with a URI identifier $i$, denoted by $e_{i} \\in \\mathcal{E}$, is a set of attribute-value pairs about a realworld entity. When the identifier of an entity description $e_{j}$ appears in the values of another entity description $e_{i}$, the corresponding attribute is called a relation and the corresponding value $\\left(e_{j}\\right)$ a neighbor of $e_{i}$. More formally, the relations of $e_{i}$ are defined as $\\operatorname{relations}\\left(e_{i}\\right)=\\left\\{p \\mid(p, j) \\in e_{i} \\wedge e_{j} \\in \\mathcal{E}\\right\\}$, while its neighbors as neighbors $\\left(e_{i}\\right)=\\left\\{e_{j} \\mid(p, j) \\in e_{i} \\wedge e_{j} \\in \\mathcal{E}\\right\\}$. For example, for the Wikidata KB in the left side of Figure 1 we have: relations(Restaurant1) $=\\{$ hasChef, territorial, inCountry $\\}$, and neighbors(Restaurant1) $=\\{$ John Lake A, Bray, United Kingdom $\\}$.\n\nIn the following, we exclusively consider clean-clean ER, i.e., the sub-problem of ER that seeks matches among two duplicatefree (clean) KBs. Thus, we simplify the presentation of our approach, but the proposed techniques can be easily generalized to more than two clean KBs or a single dirty KB, i.e., a KB that contains duplicates.\nTraditionally, similarity between entities is computed based on their values. In our work, we apply a similarity measure based on the number and the frequency of common words between two values ${ }^{4}$.\n\nDefinition 2.1. Given two KBs, $\\mathcal{E}_{1}$ and $\\mathcal{E}_{2}$, the value similarity of two entity descriptions $e_{i} \\in \\mathcal{E}_{1}, e_{j} \\in \\mathcal{E}_{2}$ is defined as: $\\operatorname{valueSim}\\left(e_{i}, e_{j}\\right)=\\sum_{t \\in \\operatorname{tokens}\\left(e_{i}\\right) \\cap t o k e n s\\left(e_{j}\\right)} \\frac{1}{\\log _{2}\\left(E F_{\\mathcal{E}_{1}}(t) \\cdot E F_{\\mathcal{E}_{2}}(t)+1\\right)}$, where $E F_{\\mathcal{E}_{i}}(t)=\\left\\{\\left\\{e_{i} \\mid e_{l} \\in \\mathcal{E} \\wedge t \\in \\operatorname{tokens}\\left(e_{l}\\right)\\right\\}\\right\\}$ stands for \"Entity Frequency\", which is the number of entity descriptions in $\\mathcal{E}$ having token $t$ in their values.\n\nThis value similarity shares the same intuition as TF-IDF in information retrieval. If two entities share many, infrequent tokens, then they have high value similarity. On the contrary, very frequent words (resembling stopwords in information retrieval) are not considered an important matching evidence, when they are shared by two descriptions, and therefore, they only contribute insignificantly to the valueSim score. The number of common words is accounted by the number of terms that are considered in the sum and the frequency of those words is given by the inverse Entity Frequency (EF), similar to the inverse Document Frequency (DF) in information retrieval.\n\nProposition 1. valueSim is a similarity metric, since it satisfies the following properties [5]:\n\n- $\\operatorname{valueSim}\\left(e_{i}, e_{i}\\right) \\geq 0$,\n- $\\operatorname{valueSim}\\left(e_{i}, e_{j}\\right)=\\operatorname{valueSim}\\left(e_{j}, e_{i}\\right)$,\n- $\\operatorname{valueSim}\\left(e_{i}, e_{i}\\right) \\geq \\operatorname{valueSim}\\left(e_{i}, e_{j}\\right)$,\n- $\\operatorname{valueSim}\\left(e_{i}, e_{i}\\right)=\\operatorname{valueSim}\\left(e_{i}, e_{j}\\right)=\\operatorname{valueSim}\\left(e_{i}, e_{j}\\right) \\Leftrightarrow e_{i}=e_{j}$,\n- $\\operatorname{valueSim}\\left(e_{i}, e_{j}\\right)+\\operatorname{valueSim}\\left(e_{j}, e_{j}\\right) \\leq \\operatorname{valueSim}\\left(e_{i}, e_{2}\\right)+$\n$\\operatorname{valueSim}\\left(e_{i}, e_{j}\\right)$.\n\n[^0]Proof. Please refer to the extended version of this paper ${ }^{5}$.\nNote that valueSim has the following properties: (i) it is not a normalized metric, since it can take any value in $\\{0,+\\infty\\}$, with 0 denoting the existence of no common tokens in the values of the compared descriptions. (ii) The maximum contribution of a single common token between two descriptions is 1 , in case this common token does not appear in the values of any other entity description, i.e., when $E F_{\\mathcal{E}_{1}}(t) \\cdot E F_{\\mathcal{E}_{2}}(t)=1$. (iii) It is a schema-agnostic similarity metric, as it disregards any schematic information ${ }^{6}$.\nIn addition to value similarity, we exploit the relations between descriptions to find the matching entities of the compared KBs. This can be done by aggregating the value similarity of all pairs of descriptions that are neighbors of the target descriptions.\n\nGiven the potentially high number of neighbors that a description might have, we propose considering only the most valuable neighbors for computing the neighbor similarity between two target descriptions. These are neighbors that are connected with the target descriptions via important relations, i.e., relations that exhibit high support and discriminability. Intuitively, high support for a particular relation $p$ indicates that $p$ appears in many entity descriptions, while high discriminability for $p$ indicates that it has many distinct values. More formally:\n\nDefinition 2.2. The support of a relation $p \\in \\mathcal{P}$ in a KB $\\mathcal{E}$ is defined as: $\\operatorname{support}(p)=\\frac{\\mid \\text { instances }(p)}{\\mid \\mathcal{E}\\left\\lceil{ }^{6}\\right.}$, where instances $(p)=$ $\\left\\{(i, j) \\mid e_{i}, e_{j} \\in \\mathcal{E} \\wedge\\left(p, j\\right) \\in e_{i}\\right\\}$.\n\nDefinition 2.3. The discriminability of a relation $p \\in \\mathcal{P}$ in a $\\mathrm{KB} \\mathcal{E}$ is defined as: $\\operatorname{discriminability}(p)=\\frac{\\mid \\text { objects }(p) \\mid}{\\mid \\text { instances }(p) \\mid}$, where $\\operatorname{objects}(p)=\\{j \\mid(i, j) \\in \\operatorname{instances}(p)\\}$.\n\nOverall, we combine support and discriminability via their harmonic mean in order to locate the most important relations.\n\nDefinition 2.4. The importance of a relation $p \\in \\mathcal{P}$ in a $\\mathrm{KB} \\mathcal{E}$ is defined as: importance $(p)=2 \\cdot \\frac{\\operatorname{support}(p) \\cdot \\operatorname{discriminability}(p)}{\\operatorname{support}(p)+\\operatorname{discriminability}(p)}$.\n\nOn this basis, we identify the most valuable relations and neighbors for every single entity description (i.e., locally). We use topNrelations $\\left(e_{i}\\right)$ to denote the $N$ relations in relations $\\left(e_{i}\\right)$ with the maximum importance scores. Then, the best neighbors for $e_{i}$ are defined as: topNneighbors $\\left(e_{i}\\right)=\\left\\{\\left.\\leftne_{i}\\right|\\left(p, n e_{i}\\right) \\in e_{i} \\wedge p \\in\\right.\\right.$ topNrelations $\\left.\\left(e_{i}\\right)\\right\\}$.\n\nIntuitively, strong matching evidence (high value similarity) for the important neighbors leads to strong matching evidence for the target pair of descriptions. Hence, we formally define neighbor similarity as follows:\n\nDefinition 2.5. Given two KBs, $\\mathcal{E}_{1}$ and $\\mathcal{E}_{2}$, the neighbor similarity of two entity descriptions $e_{i} \\in \\mathcal{E}_{1}, e_{j} \\in \\mathcal{E}_{2}$ is:\n$\\operatorname{neighborNSim}\\left(e_{i}, e_{j}\\right)=\\sum_{\\substack{n e_{i} \\in \\text { topNneighbors }\\left(e_{i}\\right) \\\\ n e_{i} \\in \\text { topNneighbors }\\left(e_{j}\\right)}} \\operatorname{valueSim}\\left(n e_{i}, n e_{j}\\right)$.\nProposition 2. neighborNSim is a similarity metric.\n\n[^1]\n[^0]:    ${ }^{4}$ We handle numbers and dates in the same way as strings, assuming string-dominated entities.\n\n[^1]:    ${ }^{5} \\mathrm{http}: / /$ csd.uoc.gr/ vefthym/DissertationEthymiou.pdf\n    ${ }^{6}$ Note that our value similarity metric is crafted for the token-level noise in literal values, rather than the character-level one. Yet, our overall approach is tolerant to character-level noise, as verified by our extensive experimental analysis with real datasets that include it. The reason is that it is highly unlikely for matching entities to have character-level noise in all their common tokens.\n\nProof. Given that neighborNSim is the sum of similarity metrics (valueSim), it is a similarity metric, too [5].\n\nNeither valueSim nor neighborNSim are normalized, since the number of terms that contribute in the sums is an important matching evidence that can be mitigated if the values were normalized.\n\nExample 2.6. Continuing our example in Figure 1, assume that the best two relations for Restaurant1 and Restaurant2 are: top2relations(Restaurant1) $=($ hasChef, territorial $)$ and top2relations(Restaurant2) $=($ headChef, county $)$. Then, top2neighbors(Restaurant1) $=($ John Lake A, Bray $]$ and top2neighbors(Restaurant2) $=($ Jonny Lake, Berkshire $]$, and neighbor2Sim(Restaurant1, Restaurant2) =\nvalueSim(Bray, JonnyLake)+valueSim(John Lake A, Berkshire) +valueSim(Bray, Berkshire)+valueSim(John Lake A, Jonny Lake). Note that since we don't have a relation mapping, we also consider the comparisons (Bray, JonnyLake) and (John Lake A, Berkshire).\n\nEntity Names. From every KB, we also derive the global top- $k$ attributes of highest importance, whose literal values act as names for any description $e_{l}$ that contains them. Their support is simply defined as: support $(p)=|$ subjects $(p)| /|\\mathcal{E}|$, where subjects $(p)=$ $\\{i \\mid(i, j) \\in$ instances $(p)\\} \\mid$ [32]. Based on these statistics, function name $\\left(e_{i}\\right)$ returns the names of $e_{i}$, and $\\mathcal{N}_{b}$ denotes all names in a KB $\\mathcal{E}_{b}$. In combination with topNneighbors $\\left(e_{i}\\right)$, this function covers both local and global property importance, exploiting both the rare and frequent attributes that are distinctive enough to designate matching entities.\n",
        "title": [
            "## 2 BASIC DEFINITIONS",
            "### 2.1 Entity similarity based on values",
            "### 2.2 Entity similarity based on neighbors"
        ],
        "summary": "This section introduces methods for computing similarity between entity descriptions in knowledge bases (KBs), focusing on clean-clean entity resolution (ER) across two duplicate-free KBs. The core approach defines a value similarity metric inspired by TF-IDF, measuring overlap between entity attribute values while down-weighting common tokens. Additionally, the method incorporates the structure of KBs by identifying and weighting important relations and their neighbors, using measures of support and discriminability to select the most informative connections. The neighbor similarity metric aggregates value similarities among these selected neighbors, while entity names are derived from globally important attributes, combining both local and global evidence for robust entity matching."
    },
    "Methodology": {
        "content": "To enhance performance, blocking is typically used as a preprocessing step for ER in order to reduce the number of unnecessary comparisons, i.e., comparisons between descriptions that do not match. After blocking, each description can be compared only to others placed within the same block. The desiderata of blocking are [6]: (i) to place matching descriptions in common blocks (effectiveness), and (ii) to minimize the number of suggested comparisons (time efficiency). However, efficiency dictates skipping many comparisons, possibly yielding many missed matches, which in turn implies low effectiveness. Thus, the main objective of blocking is to achieve a good trade-off between minimizing the number of suggested comparisons and minimizing the number of missed matches [7].\n\nIn general, blocking methods are defined over key values that can be used to decide whether or not an entity description could be placed in a block using an indesing function [7]. The 'uniqueness' of key values determines the number of entity descriptions placed in the same block, i.e., which are considered as candidate matches. More formally, the building blocks of a blocking method can be defined as [3]:\n\n- An indesing function $h_{k e y}: \\mathcal{E} \\rightarrow 2^{B}$ is a unary function that, when applied to an entity description using a specific blocking key, it returns as a value the subset of the set of all blocks $B$, under which the description will be indexed.\n- A co-occurrence function $o_{k e y}: \\mathcal{E} \\times \\mathcal{E} \\rightarrow\\{$ true, false $\\}$ is a binary function that, when applied to a pair of entity descriptions, it returns 'true' if the intersection of the sets of blocks produced by the indexing function on its arguments, is non-empty, and 'false' otherwise; $o_{k e y}\\left(e_{k}, e_{l}\\right)=$ true iff $h_{k e y}\\left(e_{k}\\right) \\cap h_{k e y}\\left(e_{l}\\right) \\neq \\emptyset$.\n\nIn this context, each pair of descriptions whose co-occurrence function returns 'true' shares at least one common block, and the\ndistinct union of the block elements is the input entity collection (i.e., all the descriptions from a set of input KBs). Formally:\n\nDefinition 3.1. Given an entity collection $\\mathcal{E}$, atomic blocking is defined by an indexing function $h_{k e y}$ for which the generated blocks, $B^{k e y} \\equiv\\left\\{b_{i}^{k e y}, \\ldots, b_{m}^{k e y}\\right\\}$, satisfy the following conditions:\n(i) $\\forall e_{k}, e_{l} \\in b_{i}^{k e y}: b_{i}^{k e y} \\in B^{k e y}, o_{k e y}\\left(e_{k}, e_{l}\\right)=$ true,\n(ii) $\\forall\\left(e_{k}, e_{l}\\right): o_{k e y}\\left(e_{k}, e_{l}\\right)=$ true, $\\exists b_{i}^{k e y} \\in B^{k e y}, e_{k}, e_{l} \\in b_{i}^{k e y}$,\n(iii) $\\bigcup_{b_{i}^{k e y} \\in B^{k e y}} b_{i}^{k e y}=\\mathcal{E}$.\n\nGiven that a single key is not enough for indexing loosely structured and highly heterogeneous entity descriptions, we need to consider several keys that the indexing function will exploit to build different sets of blocks. Such a composite blocking method is characterized by a disjunctive co-occurrence function over the atomic blocks, and it is formally defined as:\n\nDefinition 3.2. Given an entity collection $\\mathcal{E}$, disjunctive blocking is defined by a set of indexing functions $H$, for which the generated blocks $B=\\underset{h_{k e y} \\in H}{\\bigcup} B^{k e y}$ satisfy the following conditions:\n(i) $\\forall e_{k}, e_{l} \\in b: b \\in B, o_{H}\\left(e_{k}, e_{l}\\right)=$ true,\n(ii) $\\forall\\left(e_{k}, e_{l}\\right): o_{H}\\left(e_{k}, e_{l}\\right)=$ true, $\\exists b \\in B, e_{k}, e_{l} \\in b$, where $o_{H}\\left(e_{k}, e_{l}\\right)=\\bigvee_{h_{k e y} \\in H} o_{k e y}\\left(e_{k}, e_{l}\\right)$.\n\nAtomic blocking can be seen as a special case of composite blocking, consisting of a singleton set, i.e., $H=\\left\\{h_{k e y}\\right\\}$.\nTo achieve a good trade-off between effectiveness and efficiency, our composite blocking scheme assesses the name and value similarity of the candidate matches in combination with similarity evidence provided by their neighbors on important relations. We consider the blocks constructed for all entities $e_{i} \\in \\mathcal{E}$ using the indexing function $h_{i}()$ both over entity names $\\left(\\forall n_{j} \\in\\right.$ names $\\left(e_{i}\\right)$ : $h_{N}\\left(n_{j}\\right)$ ) and tokens $\\left(\\forall t_{j} \\in\\right.$ tokens $\\left(e_{i}\\right): h_{T}\\left(t_{j}\\right)$ ). The composite blocking scheme $O$ of MinoanER is defined by the following disjunctive co-occurrence condition of any two entities $e_{i}, e_{j} \\in \\mathcal{E}$ : $O\\left(e_{i}, e_{j}\\right)=o_{N}\\left(e_{i}, e_{j}\\right) \\vee o_{T}\\left(e_{i}, e_{j}\\right) \\vee$\n$\\left(\\bigvee_{\\left(e_{i}^{\\prime}, e_{j}^{\\prime}\\right) \\in t o p N n e i g h b o r s\\left(e_{i}\\right) \\in t o p N n e i g h b o r s\\left(e_{j}\\right)} o_{T}\\left(e_{i}^{\\prime}, e_{j}^{\\prime}\\right)\\right)$, where $o_{N}, o_{T}$ is the co-occurrence function applied on names and tokens, respectively. Intuitively, two entities are placed in a common block, and are then considered candidate matches, if at least one of the following three cases holds: (i) they have the same name, which is not used by any other entity, in which case the common block contains only those two entities, or (ii) they have at least one common word in any of their values, in which case the size of the common block is given by the product of the Entity Frequency $(E F)$ of the common term in the two input collections, or (iii) their top neighbors share a common word in any of their values. Note that token blocking (i.e., $h_{T}$ ) allows for deriving valueSim from the size of blocks shared by two descriptions. As a result, no additional blocks are needed to assess neighbor similarity of candidate entities: token blocking is sufficient also for estimating neighborNsim according to Definition 2.5.\nThe disjunctive blocking graph $G$ is an abstraction of the disjunctive co-occurrence condition of candidate matches in blocks. Nodes represent candidates from our input entity descriptions, while edges represent pairs of candidates for which at least one\n\n![img-2.jpeg](img-2.jpeg)\n\nFigure 3: (a) Parts of the disjunctive blocking graph corresponding to Figure 1, and (b) the corresponding blocking graph after pruning.\nof the co-occurrence conditions is 'true'. Each edge is actually labeled with three weights that quantify similarity evidence on names, tokens and neighbors of candidate matches. Specifically, the disjunctive blocking graph of MinoanER is a graph $G=$ $(V, E, \\lambda)$, with $\\lambda$ assigning to each edge a label $(\\alpha, \\beta, \\gamma)$, where $\\alpha$ is ' 1 ' if $o_{N}\\left(e_{i}, e_{j}\\right)$ is true and the name block in which $e_{i}, e_{j}$ co-occur is of size 2 , and ' 0 ' otherwise, $\\beta=$ valueSim $\\left(e_{i}, e_{j}\\right)$, and $\\gamma=$ neighbor $N \\operatorname{Sim}\\left(e_{i}, e_{j}\\right)$. More formally:\n\nDefinition 3.3. Given a block collection $B=\\bigcup_{h_{k e q} \\in H} B^{k e q}$, produced by a set of indexing functions $H$, the disjunctive blocking graph for an entity collection $\\mathcal{E}$, is a graph $G=(V, E, \\lambda)$, where each node $v_{i} \\in V$ represents a distinct description $e_{i} \\in \\mathcal{E}$, and each edge $\\left\\langle v_{i}, v_{j}\\right\\rangle \\in E$ represents a pair $e_{i}, e_{j} \\in \\mathcal{E}$ for which $\\mathcal{O}\\left(e_{i}, e_{j}\\right)={ }^{\\prime}$ true'; $\\mathcal{O}\\left(e_{i}, e_{j}\\right)$ is a disjunction of the atomic cooccurrence functions $o^{k}$ defined along with $H$, and $\\lambda: E \\rightarrow R^{n}$ is a labeling function assigning a tuple $\\left[w^{1}, \\ldots, w^{n}\\right]$ to each edge, where $w^{k}$ is a weight associated with each co-occurrence function $o^{k}$ of $H$.\n\nDefinition 3.3 covers the cases of an entity collection $\\mathcal{E}$ being composed of one, two, or more KBs. When matching $k \\mathrm{KBs}$, assuming that all of them are clean, the disjunctive blocking graph is $k$-partite, with each of the $k \\mathrm{KBs}$ corresponding to a different independent set of nodes, i.e., there are only edges between descriptions from different KBs. The only information needed to match multiple KBs is to which KB every description belongs, so as to add it to the corresponding independent set. Similarly, the disjunctive blocking graph covers dirty ER, as well.\n\nExample 3.4. Consider the graph of Figure 3(a), which is part of the disjunctive blocking graph generated from Figure 1. John Lake A and Jonny Lake have a common name (\"J. Lake\"), and there is no other entity having this name, so there is an edge connecting them with $\\alpha=1$. Bray and Berkshire have common, quite infrequent tokens in their values, so their similarity ( $\\beta$ in the edge connecting them) is quite high ( $\\beta=1.2$ ). Since Bray is a top neighbor of Restaurant1 in Figure 1, and Berkshire is a top neighbor of Restaurant2, there is also an edge with a non-zero $\\gamma$ connecting Restaurant1 with Restaurant2. The $\\gamma$ score of this edge (1.6) is the sum of the $\\beta$ scores of the edges connecting Bray with Berkshire (1.2), and John Lake A with Jonny Lake (0.4).\nEach edge in the blocking graph represents a suggested comparison between two descriptions. To reduce the number of comparisons suggested by the disjunctive blocking graph, we keep for each node the $K$ edges with the highest $\\beta$ and the $K$ edges with the highest $\\gamma$ weights, while pruning edges with trivial weights (i.e., $(\\alpha, \\beta, \\gamma)=0.0 .01$ ), since they connect descriptions unlikely to match. Given that nodes $v_{i}$ and $v_{j}$ may have different top $K$ edges based on $\\beta$ or $\\gamma$, we consider each undirected edge in $G$ as two directed ones, with the same initial weights, and perform pruning on them.\n\nExample 3.5. Figure 3(b) shows the pruned version of the graph in Figure 3(a). Note that the blocking graph is only a conceptual model, which we do not materialize; we retrieve any necessary information from computationally cheap inverted indices.\n\nThe process of weighting and pruning the edges of the disjunctive blocking graph is described in Algorithm 1. Initially, the graph contains no edges. We start adding edges by checking the name blocks $B_{N}$ (Lines 5-9). For each name block $b$ that contains exactly two entities, one from each KB, we create an edge with $\\alpha=1$ linking those entities (note that in Algorithm $1, b^{k}, k \\in\\{1,2\\}$, denotes the sub-block of $b$ that contains the entities from $\\mathcal{E}_{k}$, i.e., $b^{k} \\subseteq \\mathcal{E}_{k}$ ). Then, we compute the $\\beta$ weights (Lines 10-14) by running a variation of Meta-blocking [27], adapted to our value similarity metric (Definition 2.1). Next, we keep for each entity, its connected nodes from the $K$ edges with the highest $\\beta$ (Lines 1518). Line 20 calls the procedure for computing the top in-neighbors of each entity, which operates as follows: first, it identifies each entity's topNneigbors (Lines 36-43) and then, it gets their reverse; for every entity $e_{i}$, we get the entities topInNeighbors[ $i$ ] that have $e_{i}$ as one of their topNneighbors (Lines 44-47). This allows for estimating the $\\gamma$ weights according to Definition 2.5. To avoid re-computing the value similarities that are necessary for the $\\gamma$ computations, we exploit the already computed $\\beta \\mathrm{s}$. For each pair of entities $e_{i} \\in \\mathcal{E}_{1}, e_{j} \\in \\mathcal{E}_{2}$ that are connected with an edge with $\\beta>0$, we assign to each pair of their inNeighbors, $\\left(\\left|n_{i}, \\left|n_{j}\\right|\\right.\\right)$, a partial $\\gamma$ equal to this $\\beta$ (Lines 20-27). After iterating over all such entity pairs $e_{i}, e_{j}$, we get their total neighbor similarity, i.e., $\\gamma[i, j]=$ neighbor $N \\operatorname{sim}\\left(e_{i}, e_{j}\\right)$. Finally, we keep for each entity, its $K$ neighbors with the highest $\\gamma$ (Lines 28-33).\n\nThe time complexity of Algorithm 1 is dominated by the processing of value evidence, which iterates twice over all comparisons in the token blocks $B_{T}$. In the worst-case, this results in one computation for every pair of entities, i.e., $O\\left(\\left|\\mathcal{E}_{1}\\right| \\cdot\\left|\\mathcal{E}_{2}\\right|\\right)$. In practice, though, we bound the number of computations by removing excessively large blocks that correspond to highly frequent tokens (e.g., stop-words). Following [27], this is carried out by Block Purging [26], which ensures that the resulting blocks involve two orders of magnitude fewer comparisons than the bruteforce approach, without any significant impact on recall. This complexity is higher than that of name and neighbor evidence, which are both linearly dependent on the number of input entities. The former involves a single iteration over the name blocks $B_{N}$, which amount to $\\left|N_{1} \\cap N_{2}\\right|$, as there is one block for every name shared by $\\mathcal{E}_{1}$ and $\\mathcal{E}_{2}$. For neighbor evidence, Algorithm 1 checks all pairs of $N$ neighbors between every entity $e_{i}$ and its $K$ most value-similar descriptions, performing $K \\cdot N^{2} \\cdot\\left(\\left|\\mathcal{E}_{1}\\right|+\\left|\\mathcal{E}_{2}\\right|\\right)$ operations; the cost of estimating the top in-neighbors for each entity is lower, dominated by the ordering of all relations in $\\mathcal{E}_{1}$ and $\\mathcal{E}_{2}$ (i.e., $\\left|R_{\\text {max }}\\right| \\cdot \\log \\left|R_{\\text {max }}\\right|$ ), where $\\left|R_{\\text {max }}\\right|$ stands for the maximum number of relations in one of the KBs.\n\nAlgorithm 1: Disjunctive Blocking Graph Construction.\nInput: $\\mathcal{E}_{1}, \\mathcal{E}_{2}$, the blocks from name and token blocking, $B_{N}$ and $B_{T}$\nOutput: A disjunctive blocking graph $G$.\nprocedure getCompositeBlockingGraph( $\\mathcal{E}_{1}, \\mathcal{E}_{2}, B_{N}, B_{T}$ )\n$V \\leftarrow \\mathcal{E}_{1} \\cup \\mathcal{E}_{2}$\n$E \\leftarrow \\emptyset ;$\n$W \\leftarrow \\emptyset ; \\quad / /$ init. to $(0,0,0)$\n// Name Evidence\nfor $b \\in B_{N}$ do\nif $\\left|b^{1}\\right| \\cdot\\left|b^{1}\\right|=1$ then // only 1 comparison in $b$\n$e_{i} \\leftarrow b^{1} \\cdot \\operatorname{get}(0), e_{j} \\leftarrow b^{2} \\cdot \\operatorname{get}(0)$; // entities in b $E \\leftarrow E \\cup\\left\\{<v_{i}, v_{j}>\\right\\}$\n$W \\leftarrow W \\cdot \\operatorname{set}\\left(a,<v_{i}, v_{j}>, 1\\right)$;\n// Value Evidence\nfor $e_{i} \\in \\mathcal{E}_{1}$ do\n$\\beta[] \\leftarrow \\emptyset ; \\quad / /$ value weights wrt all $e_{j} \\in \\mathcal{E}_{2}$\nfor $b \\in B_{T} \\wedge b \\cap e_{i} \\neq \\emptyset$ do\nfor $e_{i} \\in b^{2}$ do // $e_{j} \\in \\mathcal{E}_{2}$\n$\\beta[j] \\leftarrow \\beta[j] * 1 / \\log _{2}\\left(\\left|b^{1}\\right| \\cdot\\left|b^{2}\\right| * 1\\right) ; \\quad / /$ valueSim\nValueCandidates $\\leftarrow$ getTopCandidates $(\\beta[], K)$;\nfor $e_{j} \\in$ ValueCandidates do\n$E \\leftarrow E \\cup\\left\\{<v_{i}, v_{j}>\\right\\}$\n$W \\leftarrow W \\cdot \\operatorname{set}\\left(\\beta,<v_{i}, v_{j}>, \\beta[j]\\right)$;\nfor $e_{i} \\in \\mathcal{E}_{2}$ do...; // ...do the same for $\\mathcal{E}_{2}$\n// Neighbor Evidence\ninNeighbors[] $\\leftarrow$ getTopInNeighbors $\\left(\\mathcal{E}_{1}, \\mathcal{E}_{2}\\right)$;\n$\\gamma[][] \\leftarrow \\emptyset ; \\quad / /$ neighbor weights wrt all $e_{i}, e_{j} \\in V$\nfor $e_{i} \\in \\mathcal{E}_{1}$ do\nfor $e_{i} \\in \\mathcal{E}_{2}$, s.t. $W \\cdot \\operatorname{get}\\left(\\beta,<v_{i}, v_{j}>\\right)>0$ do\nfor $i n_{j} \\in$ inNeighbors[j] do\nfor $i n_{i} \\in$ inNeighbors[i] do // neighborHSim\n$\\gamma[i][j] \\leftarrow \\gamma[i][j]+W \\cdot \\operatorname{get}\\left(\\beta,<n_{i}, n_{j}>\\right)$;\nfor $e_{i} \\in \\mathcal{E}_{2}$ do...; // ...do the same for $\\mathcal{E}_{2}$\nfor $e_{i} \\in \\mathcal{E}_{1}$ do\nNeighborCandidates $\\leftarrow$ getTopCandidates $(\\gamma[i][], K)$;\nfor $e_{j} \\in$ NeighborCandidates do\n$E \\leftarrow E \\cup\\left\\{<v_{i}, v_{j}>\\right\\}$\n$W \\cdot \\operatorname{set}\\left(\\gamma,<v_{i}, v_{j}>, \\gamma[i][j]\\right)$;\nfor $e_{i} \\in \\mathcal{E}_{2}$ do...; // ...do the same for $\\mathcal{E}_{2}$\nreturn $G=(V, E, W)$;\nprocedure getTopInNeighbors $\\left(\\mathcal{E}_{1}, \\mathcal{E}_{2}\\right)$\ntopNeighbors[] $\\leftarrow \\emptyset ; \\quad / /$ one list for each entity globalOrder $\\leftarrow$ sort $\\mathcal{E}_{1}$ 's relations by importance;\nfor $e \\in \\mathcal{E}_{1}$ do\nlocalOrder(e) $\\leftarrow$ relations(e).sortBy(globalOrder);\ntopNrelations $\\leftarrow$ localOrder(e).topN;\nfor $(p, n) \\in e$, where $p \\in$ topNrelations do\ntopNeighbors[e].add(n);\nfor $e_{i} \\in \\mathcal{E}_{2}$ do...; // ...do the same for $\\mathcal{E}_{2}$ topInNeighbors[] $\\leftarrow \\emptyset ; \\quad / /$ the reverse of topNeighbors\nfor $e \\in \\mathcal{E}_{1} \\cup \\mathcal{E}_{2}$ do\nfor $n e \\in$ topNeighbors[e] do\ntopInNeighbors $[n e] . a d d(e)$;\nreturn topInNeighbors;\nOur matching method receives as input the disjunctive blocking graph $G$ and performs four steps - unlike most existing works, which involve a data-driven iterative process. In every step, a matching rule is applied with the goal of extracting new matches from the edges of $G$ by analyzing their weights. The functionality of our algorithm is outlined in Algorithm 2. Next, we describe its rules in the order they are applied:\nName Matching Rule (R1). The matching evidence of R1 comes from the entity names. It assumes that two candidate entities\n\nAlgorithm 2: Non-iterative Matching.\nInput: $\\mathcal{E}_{1}, \\mathcal{E}_{2}$, The pruned, directed disjunctive blocking graph $G$.\nOutput: A set of matches $M$.\n$M \\leftarrow \\emptyset ; \\quad / /$ The set of matches\n// Name Matching Value (R1)\nfor $<v_{i}, v_{j}>\\in G . E$ do\nif $G . W \\cdot \\operatorname{get}\\left(a,<v_{i}, v_{j}>\\right)=1$ then\n$M \\leftarrow M \\cup\\left(e_{i}, e_{j}\\right)$;\n// Value Matching Value (R2)\nfor $v_{i} \\in G . V$ do\nif $e_{i} \\in \\mathcal{E}_{1} \\backslash M$ then // check the smallest KB for efficiency\n$v_{j} \\leftarrow \\operatorname{argmax}_{v_{k} \\in G . V} G \\cdot W \\cdot \\operatorname{get}\\left(\\beta,<v_{i}, v_{k}>\\right) ; \\quad / /$ top candidate\nif $G \\cdot W \\cdot \\operatorname{get}\\left(\\beta,<v_{i}, v_{j}>\\right) \\geq 1$ then\n$M \\leftarrow M \\cup\\left(e_{i}, e_{j}\\right)$;\n// Rank Aggregation Matching Value (R3)\nfor $v_{i} \\in G . V$ do\nif $e_{i} \\in \\mathcal{E}_{1} \\cup \\mathcal{E}_{2} \\backslash M$ then\nagg[] $\\leftarrow \\emptyset ; \\quad / /$ Aggregate scores, init. zeros\nvalCands $\\leftarrow G \\cdot \\operatorname{valCand}\\left(e_{i}\\right) ; / /$ nodes linked to $e_{i}$ in decr. $\\beta$\nrank $\\leftarrow[$ valCands];\nfor $e_{j} \\in$ valCands do\n$\\operatorname{agg}\\left[e_{i}\\right] \\cdot \\operatorname{update}\\left(e_{j}, \\theta \\cdot \\operatorname{rank} /\\mid v a l C a n d s\\right)$;\nrank $\\leftarrow$ rank -1 ;\nngbCands $\\leftarrow G \\cdot n g b C a n d\\left(e_{i}\\right) ; / /$ nodes linked to $e_{i}$ in decr. $\\gamma$\nrank $\\leftarrow[$ ngbCands];\nfor $e_{j} \\in$ ngbCands do\n$\\operatorname{agg}\\left[e_{i}\\right] \\cdot \\operatorname{update}\\left(e_{j},(1-\\theta) \\cdot \\operatorname{rank} / \\mid n g b C a n d s\\right)$;\nrank $\\leftarrow$ rank -1 ;\n$M \\leftarrow M \\cup\\left(e_{i}, \\operatorname{getTopCandidate}\\left(\\operatorname{agg}\\left[e_{i}\\right]\\right)\\right)$;\n// Reciprocity Matching Value (R4)\nfor $\\left(e_{i}, e_{j}\\right) \\in M$ do\nif $<v_{i}, v_{j}>\\notin G . E \\vee<v_{j}, v_{i}>\\notin G . E$ then\n$M \\leftarrow M \\backslash\\left(e_{i}, e_{j}\\right)$;\nreturn $M$;\nmatch, if they, and only they, have the same name $n$. Thus, R1 traverses $G$ and for every edge $\\ll v_{i}, v_{j}>$ with $\\alpha=1$, it updates the set of matches $M$ with the corresponding descriptions (Lines 2-4 in Alg. 2). All candidates matched by R1 are not examined by the remaining rules.\nValue Matching Rule (R2). It presumes that two entities match, if they, and only they, share a common token $t$, or, if they share many infrequent tokens. Based on Definition 2.1, R2 identifies pairs of descriptions with high value similarity (Lines 5-9). To this end, it goes through every node $v_{i}$ of $G$ and checks whether the corresponding description stems from the smaller in size KB, for efficiency reasons (fewer checks), but has not been matched yet. In this case, it locates the adjacent node $v_{j}$ with the maximum $\\beta$ weight (Line 7). If $\\beta \\geq 1$, R2 considers the pair $\\left(e_{i}, e_{j}\\right)$ to be a match. Matches identified by R2 will not be considered in the sequel.\nRank Aggregation Matching Rule (R3). This rule identifies further matches for candidates whose value similarity is low $(\\beta<1)$, yet their neighbor similarity $(\\gamma)$ could be relatively high. In this respect, the order of candidates rather than their absolute similarity values are used. Its functionality appears in Lines 10-23 of Algorithm 2. In essence, R3 traverses all nodes of $G$ that correspond to a description that has not been matched yet. For every such node $v_{i}$, it retrieves two lists: the first one contains adjacent edges with a non-zero $\\beta$ weight, sorted in descending order (Line 13), while\n\n![img-3.jpeg](img-3.jpeg)\n\nFigure 4: The architecture of MinoanER in Spark.\nthe second one includes the adjacent edges sorted in decreasing non-zero $\\gamma$ weights (Line 18). Then, R3 aggregates the two lists by considering the normalized ranks of their elements: assuming the size of a list is $K$, the first candidate gets the score $K / K$, the second one $(K-1) / K$, while the last one $1 / K$. Overall, each adjacent node of $v_{i}$ takes a score equal to the weighted summation of its normalized ranks in the two lists, as determined through the trade-off parameter $\\theta \\in(0,1)$ (Lines $16 \\& 21$ ): the scores of the $\\beta$ list are weighted with $\\theta$ and those of the $\\gamma$ list with $1-\\theta$. At the end, $v_{i}$ is matched with its top-1 candidate match $v_{j}$, i.e., the one with the highest aggregate score (Line 23). Intuitively, R3 matches $e_{i}$ with $e_{j}$, when, based on all available evidence, there is no better candidate for $e_{i}$ than $e_{j}$.\nReciprocity Matching Rule (R4). It aims to clean the matches identified by R1, R2 and R3 by exploiting the reciprocal edges of $G$. Given that the originally undirected graph $G$ becomes directed after pruning (as it retains the best edges per node), a pair of nodes $v_{i}$ and $v_{j}$ are reciprocally connected when there are two edges between them, i.e., an edge from $v_{i}$ to $v_{j}$ and an edge from $v_{j}$ to $v_{i}$. Hence, R4 aims to improve the precision of our algorithm based on the rationale that two entities are unlikely to match, when one of them does not even consider the other to be a candidate for matching. Intuitively, two entity descriptions match, only if both of them \"agree\" that they are likely to match. R4 essentially iterates over all matches detected by the above rules and discards those missing any of the two directed edges (Lines 24-26), acting more like a filter for the matches suggested by the previous rules.\n\nGiven a pruned disjunctive blocking graph, every rule can be formalized as a function that receives a pair of entities and returns true $(T)$ if the entities match according to the rule's rationale, or false $(F)$ otherwise, i.e., $R n: \\mathcal{E}_{1} \\times \\mathcal{E}_{2} \\rightarrow\\{T, F\\}$. In this context, we formally define the MinoanER matching process as follows:\n\nDefinition 4.1. The non-iterative matching of two $\\mathrm{KBs} \\mathcal{E}_{1}$, $\\mathcal{E}_{2}$, denoted by the Boolean matrix $M\\left(\\mathcal{E}_{1}, \\mathcal{E}_{2}\\right)$, is defined as a filtering problem of the pruned disjunctive blocking graph $G$ : $M\\left(e_{i}, e_{j}\\right)=\\left(\\mathrm{R} 1\\left(e_{i}, e_{j}\\right) \\vee \\mathrm{R} 2\\left(e_{i}, e_{j}\\right) \\vee \\mathrm{R} 3\\left(e_{i}, e_{j}\\right)\\right) \\wedge \\mathrm{R} 4\\left(e_{i}, e_{j}\\right)$.\n\nThe time complexity of Algorithm 2 is dominated by the size of the pruned blocking graph $G$ it receives as input, since R1, R2 and R3 essentially go through all directed edges in $G$ (in practice, though, R1 reduces the edges considered by R2 and R3, and so does R2 for R3). In the worst case, $G$ contains $2 K$ directed edges for every description in $\\mathcal{E}_{1} \\cup \\mathcal{E}_{2}$, i.e., $\\left|V\\right|_{\\text {inact }}=2 \\cdot K \\cdot\\left(\\left|\\mathcal{E}_{1}\\right|+\\left|\\mathcal{E}_{2}\\right|\\right)$. Thus, the overall complexity is linear with respect to the number of input descriptions, i.e., $O\\left(\\left|\\mathcal{E}_{1}\\right|+\\left|\\mathcal{E}_{2}\\right|\\right)$, yielding high scalability.\nFigure 4 shows the architecture of MinoanER implementation in Spark. Each process is executed in parallel for different chunks of input, in different Spark workers. Each dashed edge represents a synchronization point, at which the process has to wait for results produced by different data chunks (and different Spark workers).\n\nIn more detail, Algorithm 1 is adapted to Spark by applying name blocking simultaneously with token blocking and the extraction of top neighbors per entity. Name blocking and token blocking produce the sets of blocks $B_{N}$ and $B_{T}$, respectively, which are part of the algorithm's input. The processing of those blocks in order to estimate the $\\alpha$ and $\\beta$ weights (Lines 5-9 for $B_{N}$ and Lines 10-18 for $B_{T}$ ) takes place during the construction of the blocks. The extraction of top neighbors per entity (Line 20) runs in parallel to these two processes and its output, along with the $\\beta$ weights, is given to the last part of the graph construction, which computes the $\\gamma$ weights for all entity pairs with neighbors co-occuring in at least one block (Lines 21-33).\n\nTo minimize the overall run-time, Algorithm 2 is adapted to Spark as follows: R1 (Lines 2-4) is executed in parallel with name blocking and the matches it discovers are broadcasted to be excluded from subsequent rules. R2 (Lines 5-9) runs after both R1 and token blocking have finished, while R3 (Lines 10-23) runs after both R2 and the computation of neighbor similarities have been completed, skipping the already identified (and broadcasted) matches. R4 (Lines 24-26) runs in the end, providing the final, filtered set of matches. Note that during the execution of every rule, each Spark worker contains only the partial information of the disjunctive blocking graph that is necessary to find the match of a specific node (i.e., the corresponding lists of candidates based on names, values, or neighbors).\nINRIA-Paris and Univ. of Crete\nvassilis.christophides@inria.fr\n![img-0.jpeg](img-0.jpeg)\n\nFigure 1: Parts of entity graphs, representing the Wikidata (left) and DBpedia (right) KBs.\nhow diverse properties are used to describe even substantially similar entities (e.g., only 109 out of $\\sim 2,600$ LOD vocabularies are shared by more than one KB). Finally, KBs are of widely differing quality, with significant differences in the coverage, accuracy and timeliness of data provided [9]. Even in the same domain, various inconsistencies and errors in entity descriptions may arise, due to the limitations of the automatic extraction tools [34], or of the crowd-sourced contributions.\n\nThe Web of Data essentially calls for novel ER solutions that relax a number of assumptions underlying state-of-the-art methods. The most important one is related to the notion of similarity that better characterizes entity descriptions in the Web of Data - we define an entity description to be a URI-identifiable set of attributevalue pairs, where values can be literals, or the URIs of other descriptions, this way forming an entity graph. Clearly, Variety results in extreme schema heterogeneity, with an unprecedented number of attribute names that cannot be unified under a global schema [15]. This situation renders all schema-based similarity measures that compare specific attribute values inapplicable [15]. We thus argue that similarity evidence of entities within and across KBs can be obtained by looking at the bag of strings contained in descriptions, regardless of the corresponding attributes. As this value-based similarity of entity pairs may still be weak, due to a highly heterogeneous description content, we need to consider additional sources of matching evidence; for instance, the similarity of neighboring entities, which are interlinked via various semantic relations.\n\nFigure 1 presents parts of the Wikidata and DBpedia KBs, showing the entity graph that captures connections inside them. For example, Restaurant2 and Jonny Lake are neighbor entities in this graph, connected via a \"headChef\" relation. If we compare John Lake A to Jonny Lake based on their values only, it is easy\n\n\n[^0]:    * Work conducted during the Ph.D research of the author at ICS-FORTH.\n    ${ }^{1}$ https://lsd-cloud.net\n    (c) 2019 Copyright held by the owner/author(s). Published in Proceedings of the 22nd International Conference on Extending Database Technology (EDBT), March 26-29, 2019, ISBN 978-3-89318-081-3 on OpenProceedings.org.\n    Distribution of this paper is permitted under the terms of the Creative Commons license CC-by-nc-nd 4.0.\n\n![img-1.jpeg](img-1.jpeg)\n\nFigure 2: Value and neighbor similarity distribution of matches in 4 datasets (see Table 1 for more details).\nto infer that those descriptions are matching; they are strongly similar. However, we cannot be that sure about Restaurant1 and Restaurant2, if we only look at their values. Those descriptions are nearly similar and we have to look further at the similarity of their neighbors (e.g, John Lake A and Jonny Lake) to verify that they match.\n\nFigure 2 depicts both sources of similarity evidence (valueSim, neighborSim) for entities known to match (i.e., ground truth) in four benchmark datasets that are frequently used in the literature (details in Table 1). Every dot corresponds to a matching pair of entities, and its shape denotes its origin KBs. The horizontal axis reports the normalized value similarity (weighted Jaccard coefficient [21]) based on the tokens (i.e., single words in attribute values) shared by a pair of descriptions, while the vertical one reports the maximum value similarity of their neighbors. The value similarity of matching entities significantly varies across different KBs. For strongly similar entities, e.g., with a value similarity $>0.5$, existing duplicate detection techniques work well. However, a large part of the matching pairs of entities is covered by nearly similar entities, e.g., with a value similarity $<0.5$. To resolve them, we need to additionally exploit evidence regarding the similarity of neighboring entities.\n\nThis also requires revisiting the blocking (aka indexing) techniques used to reduce the number of candidate pairs [7]. To avoid restricting candidate matches (i.e., descriptions placed on the same block) to strongly similar entities, we need to assess both value and neighbor similarity of candidate matches. In essence, rather than a unique indexing function, we need to consider a composite blocking that provides matching evidence from different sources, such as the content, the neighbors or even the names (e.g., rdfs:label) of entities. Creating massively parallelizable techniques for processing the search space of candidate pairs formed by such composite blocking is an open research challenge.\n\nOverall, the main requirements for Web-scale ER are: (i) identify both strongly and nearly similar matches, (ii) do not rely on a given schema, (iii) do not rely on domain experts for aligning relations and matching rules, (iv) develop non-iterative solutions to avoid late convergence, and (v) scale to massive volumes of data. None of the existing ER frameworks proposed for the Web of\n\nData (e.g., LINDA [4], SiGMa [21] and RiMOM [31]) simultaneously fulfills all these requirements. In this work, we present the MinoanER framework for a Web-scale ER ${ }^{2}$. More precisely, we make the following contributions:\n\n- We leverage a token-based similarity of entity descriptions, introduced in [27], to define a new metric for the similarity of a set of neighboring entity pairs that are linked via important relations to the entities of a candidate pair. Rather than requiring an a priori knowledge of the entity types or of their correspondences, we rely on simple statistics over two KBs to recognize the most important entity relations involved in their neighborhood, as well as, the most distinctive attributes that could serve as names of entities beyond the rdfs:label, which is not always available in descriptions.\n- We exploit several indexing functions to place entity descriptions in the same block either because they share a common token in their values, or they share a common name. Then, we introduce a novel abstraction of multiple sources of matching evidence regarding a pair of entities (from the content, neighbors, or the names of their descriptions) under the form of a disjunctive blocking graph. We present an efficient algorithm for weighting and then pruning the edges with low weights, which are unlikely to correspond to matches. As opposed to existing disjunctive blocking schemes [3, 18], our disjunctive blocking is schema-agnostic and requires no (semi-)supervised learning.\n- We propose a non-iterative matching process that is implemented in Spark [36]. Unlike the data-driven convergence of existing systems (e.g., LINDA [4], SiGMa [21], RiMOM [31]), the matching process of MinoanER involves a specific number of predefined generic, schema-agnostic matching rules (R1-R4) that traverse the blocking graph. First, we identify matches based on their name (R1). This is a very effective method that can be applied to all descriptions, regardless of their values or neighbor similarity. Unlike the schema-based blocking keys of relational descriptions usually provided by domain experts, MinoanER automatically specifies distinctive names of entities from data statistics. Then, the value similarity is exploited to find matches with many common and infrequent tokens, i.e., strongly similar matches (R2). When value similarity is not high, nearly similar matches are identified based on both value and neighbors' similarity using a threshold-free rank aggregation function (R3), as opposed to existing works that combine different matching evidence into an aggregated score. Finally, reciprocal evidence of matching is exploited as a verification of the returned results: only entities that are mutually ranked in the top positions of their unified ranking lists are considered matches (R4). Figure 2 abstractly illustrates the type of matching pairs that are covered by each matching rule.\n- We experimentally compare the effectiveness of MinoanER against state-of-the-art methods using established benchmark data that involve real KBs. The main conclusion drawn from our experiments is that MinoanER achieves at least equivalent performance over KBs exhibiting a low Variety (e.g., those originating from a common data source like Wikipedia) even though the latter make more assumptions about the input KBs (e.g., alignment of relations); yet, MinoanER significantly outperforms state-of-theart ER tools when matching KBs with high Variety. The source code and datasets used in our experimental study are publicly available ${ }^{3}$.\n\nThe rest of the paper is structured as follows: we introduce our value and neighbor similarities in Section 2, and we delve into the\n\n[^0]\n[^0]:    ${ }^{2}$ A preliminary, abridged version of this paper appeared in [13].\n    ${ }^{3}$ http://csd.usc.gr/ vefthym/minoanER\n\nblocking schemes and the blocking graph that lie at the core of our approach in Section 3. Section 4 describes the matching rules of our approach along with their implementation in Spark, while Section 5 overviews the main differences with the state-of-the-art ER methods. We present our thorough experimental analysis in Section 6 and we conclude the paper in Section 7.\nVasilis Efthymiou*<br>IBM Research<br>vasilis.efthymiou@ibm.com<br>Kostas Stefanidis<br>Univeristy of Tampere<br>konstantinos.stefanidis@tuni.fi\n\nVasilis Christophides<br>INRIA-Paris and Univ. of Crete<br>vassilis.christophides@inria.fr\nUniversity of Athens\ngpapadis@di.uoa.gr\n",
        "title": [
            "## 3 BLOCKING",
            "### 3.1 Composite Blocking Scheme",
            "### 3.2 Disjunctive Blocking Graph",
            "### 3.3 Graph Weighting and Pruning Algorithms",
            "## 4 NON-ITERATIVE MATCHING PROCESS",
            "### 4.1 Implementation in Spark",
            "## Vassilis Christophides",
            "# MinoanER_ Schema-Agnostic, Non-Iterative, Massively Parallel Resolution of Web Entities",
            "## George Papadakis"
        ],
        "summary": "This section introduces the MinoanER framework for large-scale entity resolution (ER) over heterogeneous knowledge bases (KBs) on the Web of Data, focusing on overcoming schema heterogeneity and the limitations of existing blocking and matching methods. It details a composite, schema-agnostic blocking approach that leverages multiple indexing functions over entity names, values, and neighbors to generate a disjunctive blocking graph, which efficiently identifies candidate pairs while balancing recall and efficiency. The section also describes a non-iterative, rule-based matching process implemented in Spark, where matches are successively identified by name, value similarity, rank aggregation of value and neighbor similarities, and finally filtered by reciprocity to ensure mutual agreement. Through this design, MinoanER addresses the challenges of high variety, large scale, and lack of schema alignment in Web data, enabling scalable and effective entity matching without supervised learning or domain expertise."
    },
    "Related Work": {
        "content": "To the best of our knowledge, there is currently no other Webscale ER framework that is fully automated, non-iterative, schemiagnostic and massively parallel, at the same time. For example, WIntel [22] is a framework that performs multi-type ER, also incorporating the steps of blocking, schema-level mapping and data fusion. However, it is implemented in a sequential fashion and its solution relies on a specific level of structuredness, i.e., on a schema followed by the instances to be matched. Dedoop [20] is a highly scalable ER framework that comprises the steps of blocking and supervised matching. However, it is the user that is responsible for selecting one of the available blocking and learning methods and for fine-tuning their internal parameters. This approach is also targeting datasets with a predefined schema. Dedupe [16] is a scalable open-source Python library (and a commercial tool built on this library) for ER; however, it is not fully automated, as it performs active learning, relying on human experts to decide for a first few difficult matching decisions. Finally, we consider progressive ER (e.g., [1]) orthogonal to our approach, as it aims to retrieve as many matches as possible as early as possible.\n\nIn this context, we compare MinoanER independently to state-of-the-art matching and blocking approaches for Web data.\n\nEntity Matching. Two types of similarity measures are commonly used for entity matching [21, 31]. (i) Value-based similarities (e.g., Jaccard, Dice) usually assess the similarity of two descriptions based on the values of specific attributes. Our value similarity is a variation of ARCS, a Meta-blocking weighting scheme [12], which disregards any schema information and considers each entity description as a bag of words. Compared to\n\nARCS, though, we focus more on the number than the frequency of common tokens between two descriptions. (ii) Relational similarity measures additionally consider neighbor similarity by exploiting the value similarity of (some of) the entities' neighbors.\n\nBased on the nature of the matching decision, ER can be characterized as pairwise or collective. The former relies exclusively on the value similarity of descriptions to decide if they match (e.g., [20]), while the latter iteratively updates the matching decision for entities by dynamically assessing the similarity of their neighbors (e.g., [2]). Typically, the starting point for this similarity propagation is a set of seed matches identified by a value-based blocking.\n\nFor example, SiGMa [21] starts with seed matches having identical entity names. Then, it propagates the matching decisions on the 'compatible' neighbors, which are linked with pre-aligned relations. For every new matched pair, the similarities of the neighbors are recomputed and their position in the priority queue is updated. LINDA [4] differs by considering as compatible neighbors those connected with relations having similar names (i.e., small edit distance). However, this requirement rarely holds in the extreme schema heterogeneity of Web data. RiMOM-IM [23, 31] is a similar approach, introducing the following heuristic: if two matched descriptions $e_{1}, e_{1}^{\\prime}$ are connected via aligned relations $r$ and $r^{\\prime}$ and all their entity neighbors via $r$ and $r^{\\prime}$, except $e_{2}$ and $e_{2}^{\\prime}$, have been matched, then $e_{2}$ and $e_{2}^{\\prime}$ are also considered matches.\n\nAll these methods employ Unique Mapping Clustering for detecting matches: they place all pairs into a priority queue, in decreasing similarity. At each iteration, the top pair is considered a match, if none of its entities has been already matched. The process ends when the top pair has a similarity lower than $t$.\n\nMinoanER employs Unique Mapping Clustering, too. Yet, it differs from SiGMa, LINDA and RiMOM-IM in five ways: (i) the matching process iterates over the disjunctive blocking graph, instead of the initial KBs. (ii) MinoanER employs statistics to automatically discover distinctive entity names and important relations. (iii) MinoanER exploits different sources of matching evidence (values, names and neighbors) to statically identify candidate matches already from the step of blocking. (iv) MinoanER does not aggregate different similarities in one similarity score; instead, it uses a disjunction of the different evidence it considers. (v) MinoanER is a static collective ER approach, in which all sources of similarity are assessed only once per candidate pair. By considering a composite blocking not only on the value but also on the neighbors similarity, we discover in a non-iterative way most of the matches returned by the data-driven convergence of existing systems, or even more (see Section 6).\n\nPARIS [33] uses a probabilistic model to identify matches, based on previous matches and the functional nature of entity relations. A relation is considered functional if, for a source entity, there is only one destination entity. If $r(x, y)$ is a function in one KB and $r\\left(x, y^{\\prime}\\right)$ a function in another KB, then $y$ and $y^{\\prime}$ are considered matches. The functionality of a relation and the alignment of relations along with previous matching decisions determine the decisions in subsequent iterations. Unlike MinoanER, PARIS cannot deal with structural heterogeneity, while it targets both ontology and instance matching.\n\nFinally, [30] parallelizes the collective ER approach of [2], relying on a black-box matching and exploits a set of heuristic rules for structured entities. It essentially runs multiple instances of the matching algorithm in subsets of the input entities (similar to blocks), also keeping information for all the entity neighbors, needed for similarity propagation. Since some rules may require\nthe results of multiple blocks, an iterative message-passing framework is employed. Rather than a block-level synchronization, the MinoanER parallel computations in Spark require synchronization only across the 4 generic matching rules (see Figure 4).\n\nRegarding the matching rules, the ones employed by MinoanER based on values and names are similar to rules that have already been employed in the literature individually (e.g., in [21, 23, 31]). In this work, we use a combination of those rules for the first time, also introducing a novel rank aggregation rule to incorporate value and neighbor matching evidence. Finally, the idea of reciprocity has been applied to enhance the results of Meta-blocking [28], but was never used in matching.\n\nBlocking. Blocking techniques for relational databases [6] rely on blocking keys defined at the schema-level. For example, the Sorted Neighborhood approach orders entity descriptions according to a sorting criterion and performs blocking based on it; it is expected that matching descriptions will be neighbors after the sorting, so neighbor descriptions constitute candidate matches [17]. Initially, entity descriptions are lexicographically ordered based on their blocking keys. Then, a window, resembling a block, of fixed length slides over the ordered descriptions, each time comparing only the contents of the window. An adaptive variation of the sorted neighborhood method is to dynamically decide on the size of the window [35]. In this case, adjacent blocking keys in the sorted descriptions that are significantly different from each other, are used as boundary pairs, marking the positions where one window ends and the next one starts. Hence, this variation creates non-overlapping blocks. In a similar line of work, the sorted blocks method [11] allows setting the size of the window, as well as the degree of desired overlap.\n\nAnother recent schema-based blocking method uses Maximal Frequent Itemsets (MFI) as blocking keys [19] - an itemset can be a set of tokens. Abstractly, each MFI of a specific attribute in the schema of a description defines a block, and descriptions containing the tokens of an MFI for this attribute are placed in a common block. Using frequent itemsets to construct blocks may significantly reduce the number of candidates for matching pairs. However, since many matching descriptions share few, or even no common tokens, further requiring that those tokens are parts of frequent itemsets is too restrictive. The same applies to the requirement for a-priori schema knowledge and alignment, thus resulting in many missed matches in the Web of Data.\n\nAlthough blocking has been extensively studied for tabular data, the proposed approaches cannot be used for the Web of Data, since their blocking keys rely on the existence of a global schema. However, the use of schema-based blocking keys is inapplicable to the Web of Data, due to its extreme schema heterogeneity [15]: entity descriptions do not follow a fixed schema, as even a single description typically uses attributes defined in multiple LOD vocabularies. In this context, schema-agnostic blocking methods are needed instead. Yet, the schema-agnostic functionality of most blocking methods requires extensive fine-tuning to achieve high effectiveness [29]. The only exception is token blocking, which is completely parameter-free [26]. Another advantage of token blocking is that it allows for computing value similarity from its blocks, as they contain entities with identical blocking keys unlike other methods like Dedoop [20] and Sorted Neighborhood [17], whose blocks contain entities with similar keys.\n\nSiGMa [21] considers descriptions with at least two common tokens as candidate matches, which is more precise than our token blocking, but misses more matches. The missed matches will be considered in subsequent iterations, if their neighbor similarity is\n\nTable 1: Dataset statistics.\n\n|  | Restau- <br> rant | Rexa- <br> DBLP | BBCmusic- <br> DBpedia | YAGO- <br> IMDb |\n| :-- | :--: | :--: | :--: | :--: |\n| $E_{1}$ entities | 339 | 18,492 | 58,793 | $5,208,100$ |\n| $E_{2}$ entities | 2,256 | $2,650,832$ | 256,602 | $5,328,774$ |\n| $E_{3}$ triples | 1,130 | 87,519 | 456,304 | $27,547,595$ |\n| $E_{4}$ triples | 7,519 | $14,936,373$ | $8,044,247$ | $47,843,680$ |\n| $E_{5}$ av. tokens | 20.44 | 40.71 | 81.19 | 15.56 |\n| $E_{5}$ av. tokens | 20.61 | 59.24 | 324.75 | 12.49 |\n| $E_{1} / E_{2}$ attributes | 7 / 7 | $114 / 145$ | $27 / 10,953$ | 65 / 29 |\n| $E_{1} / E_{3}$ relations | 2 / 2 | $103 / 123$ | $9 / 953$ | 4 / 13 |\n| $E_{1} / E_{3}$ types | 3 / 3 | 4 / 11 | $4 / 59,801$ | $11,767 / 15$ |\n| $E_{1} / E_{3}$ vocab. | 2 / 2 | 4 / 4 | 4 / 6 | 3 / 1 |\n| Matches | 89 | 1,309 | 22,770 | 56,683 |\n\nstrong, whereas MinoanER identifies such matches from the step of blocking. RiMOM-IM [31] computes the tokens' TF-IDF weights, takes the top-5 tokens of each entity, and constructs a block for each one, along with the attribute this value appears. Compared to the full automation of MinoanER, this method requires attribute alignment. [25] iteratively splits large blocks into smaller ones by adding attributes to the blocking key. This leads to a prohibitive technique for voluminous KBs of high Variety.\n\nDisjunctive blocking schemes have been proposed for KBs of high [18] and low [3] levels of schema heterogeneity. Both methods, though, are of limited applicability, as they require labelled instances for their supervised learning. In contrast, MinoanER copes with the Volume and Variety of the Web of Data, through an unsupervised, schema-agnostic, disjunctive blocking.\n\nFinally, LSH blocking techniques (e.g., [24]) hash descriptions multiple times, using a family of hash functions, so that similar descriptions are more likely to be placed into the same bucket than dissimilar ones. This requires tuning a similarity threshold between entity pairs, above which they are considered candidate matches. This tuning is non-trivial, especially for descriptions from different domains, while its effectiveness is limited for nearly similar entities (see Figure 2).\n",
        "title": [
            "## 5 RELATED WORK"
        ],
        "summary": "This section reviews and contrasts existing frameworks and methods for Web-scale Entity Resolution (ER) in terms of automation, schema dependence, scalability, and parallelism, highlighting the unique features and limitations of each. It details the various entity matching approaches\u2014value-based, relational, pairwise, and collective\u2014alongside their mechanisms for similarity measurement and clustering, and explains how MinoanER distinguishes itself through fully automated, schema-agnostic, and parallelized processes that integrate multiple sources of matching evidence without iterative similarity propagation. The section also surveys blocking techniques, emphasizing the challenges posed by schema heterogeneity on the Web of Data, and underscores MinoanER\u2019s unsupervised, disjunctive, schema-agnostic blocking as superior to prior methods that require schema alignment, manual tuning, or supervised learning. Overall, the section positions MinoanER as a novel solution that addresses the shortcomings of existing ER tools for large, heterogeneous datasets."
    },
    "Experiment": {
        "content": "In this section, we thoroughly compare MinoanER to state-of-theart tools and a heavily fine-tuned baseline method.\nExperimental Setup. All experiments were performed on top of Apache Spark v2.1.0 and Java 8, on a cluster of 4 Ubuntu 16.04.2 LTS servers. Each server has 236GB RAM and 36 Intel(R) Xeon(R) E5-2630 v4 @2.20GHz CPU cores.\nDatasets. We use four established benchmark datasets with entities from real KBs. Their technical characteristics appear in Table 1. All KBs contain relations between the described entities.\n\nRestaurant ${ }^{7}$ contains descriptions of restaurants and their addresses from two different KBs. It is the smallest dataset in terms of the number of entities, triples, entity types ${ }^{8}$, as well as the one using the smallest number of vocabularies. We use it for two reasons: (i) it is a popular benchmark, created by the Ontology Alignment Evaluation Initiative, and (ii) it offers a good example of a dataset with very high value and neighbor similarity between matches (Figure 2), involving the easiest pair of KBs to resolve.\n\nRexa-DBLP ${ }^{9}$ contains descriptions of publications and their authors. The ground truth contains matches between both publications and authors. This dataset contains strongly similar matches in terms of values and neighbors (Figure 2). Although it is relatively\n\n[^0]Table 2: Block statistics.\n\n|  | Restaurant | Rexa- <br> DBLP | BBCmusic- <br> DBpedia | YAGO- <br> IMDb |\n| :--: | :--: | :--: | :--: | :--: |\n| $\\left\\|B_{N}\\right\\|$ | 83 | 15,912 | 28,844 | 580,518 |\n| $\\left\\|B_{T}\\right\\|$ | 625 | 22,297 | 54,380 | 495,973 |\n| $\\left\\|\\left|B_{N}\\right|\\right\\|$ | 83 | $6.71 \\cdot 10^{7}$ | $1.25 \\cdot 10^{7}$ | $6.59 \\cdot 10^{6}$ |\n| $\\left\\|\\left|B_{T}\\right|\\right\\|$ | $1.80 \\cdot 10^{5}$ | $6.54 \\cdot 10^{8}$ | $1.73 \\cdot 10^{8}$ | $2.28 \\cdot 10^{10}$ |\n| $\\left\\|E_{1}\\right\\| \\cdot\\left\\|E_{2}\\right\\|$ | $7.65 \\cdot 10^{7}$ | $4.90 \\cdot 10^{10}$ | $1.51 \\cdot 10^{10}$ | $2.78 \\cdot 10^{14}$ |\n| Precision | 4.95 | $1.81 \\cdot 10^{-4}$ | 0.01 | $2.46 \\cdot 10^{-8}$ |\n| Recall | 100.00 | 99.77 | 99.83 | 99.35 |\n| F1 | 9.43 | $3.62 \\cdot 10^{-4}$ | 0.02 | $4.92 \\cdot 10^{-9}$ |\n\neasy to resolve, Table 1 shows that it exhibits the greatest difference with respect to the size of the KBs to be matched (DBLP is 2 orders of magnitude bigger than Rexa in terms of descriptions, and 3 orders of magnitude in terms of triples).\n\nBBCmusic-DBpedia [14] contains descriptions of musicians, bands and their birthplaces, from BBCmusic and the BTC2012 version of DBpedia ${ }^{10}$. In our experiments, we consider only entities appearing in the ground truth, as well as their immediate in- and out-neighbors. The most challenging characteristic of this dataset is the high heterogeneity between its two KBs in terms of both schema and values: DBpedia contains $\\sim 11,000$ different attributes, $\\sim 60,000$ entity types, 953 relations, the highest number of different vocabularies (6), while using on average 4 times more tokens than BBCmusic to describe an entity. The latter feature means that all normalized, set-based similarity measures like Jaccard fail to identify such matches, since a big difference in the token set sizes yields low similarity values (see Figure 2). A thorough investigation has shown that in the median case, an entity description in this dataset contains only 2 words in its values that are used by both KBs [14].\n$Y A G O-I M D b[33]$ contains descriptions of movie-related entities (e.g., actors, directors, movies) from YAGO ${ }^{11}$ and IMDb ${ }^{12}$. Figure 2 shows that a large number of matches in this dataset has low value similarity, while a significant number has high neighbor similarity. Moreover, this is the biggest dataset in terms of entities and triples, challenging the scalability of ER tools, while it is the most balanced pair of KBs with respect to their relative size.\nBaselines. In our experiments, we compare MinoanER against four state-of-the-art methods: SiGMa, PARIS, LINDA and RiMOM. PARIS is openly available, so we ran its original implementation. For the remaining tools, we report their performance from the original publications ${ }^{13}$. We also consider BSL, a custom baseline method that receives as input the disjunctive blocking graph $G$, before pruning, and compares every pair of descriptions connected by an edge in $G$. The resulting similarities are then processed by Unique Mapping Clustering. Unlike MinoanER, though, BSL disregards all evidence from entity neighbors, relying exclusively on value similarity. Yet, it optimizes its performance through a series of well-established string matching methods that undergo extensive fine-tuning on the basis of the ground-truth.\n\nIn more detail, we consider numerous configurations for the four parameters of BSL in order to maximize its F1: (i) The schema-agnostic representation of the values in every entity. BSL uses token $n$-grams for this purpose, with $n \\in\\{1,2,3\\}$, thus representing every resource by the token uni-/bi-/tri-grams that appear\n\n[^1]\n[^0]:    ${ }^{7}$ http://oaei.ontologymatching.org/2010/im/\n    ${ }^{8}$ Extracted using the attribute w3.org/1999/02/22-rdf-syntax-ns\\#type.\n    ${ }^{9}$ oaei.ontologymatching.org/2009/instances/\n\n[^1]:    ${ }^{10}$ databab.io/dataset/bbc-music, km.aifb.kit.edu/projects/btc-2012/\n    ${ }^{11}$ www.yago-knowledge.org\n    ${ }^{12}$ www.imdb.com\n    ${ }^{13}$ RiMOM-IM [31] is openly available, but no execution instructions were made available to us.\n\n![img-4.jpeg](img-4.jpeg)\n\nFigure 5: Sensitivity analysis of the four configuration parameters of our MinoanER.\nin its values. (ii) The weighting scheme that assesses the importance of every token. We consider TF and TF-IDF weights. (iii) The similarity measure, for which we consider the following wellestablished similarities: Cosine, Jaccard, Generalized Jaccard and SiGMa (which applies exclusively to TF-IDF weights [21]). All measures are normalized to $[0,1]$. (iv) The similarity threshold that prunes the entity pairs processed by Unique Mapping Clustering. We use all thresholds in $[0,1)$ with a step of 0.05 . In total, we consider 420 different configurations, reporting the highest F1.\nBlocks Performance. First, we examine the performance of the blocks used by MinoanER (and BSL). Their statistics appear in Table 2. We observe that the number of comparisons in token blocks $\\left(\\left\\|B_{T}\\right\\|\\right)$ is at least 1 order of magnitude larger than those of name blocks $\\left(\\left\\|B_{N}\\right\\|\\right)$, even if the latter may involve more blocks $\\left(\\left|B_{N}\\right|>\\left|B_{T}\\right|\\right.$ over YAGO-IMDb). In fact, $\\left\\|B_{N}\\right\\|$ seems to depend linearly on the number of input descriptions, whereas $\\left\\|B_{T}\\right\\|$ seems to depend quadratically on that number. Nevertheless, the overall comparisons in $B_{T} \\cup B_{N}$ are at least 2 orders of magnitude lower than the Cartesian product $\\left|E_{1}\\right| \\cdot\\left|E_{2}\\right|$, even though recall is consistently higher than $99 \\%$. On the flip side, both precision and F-Measure (F1) remain rather low.\nParameter Configuration. Next, we investigate the robustness of our method with respect to its internal configuration. To this end, we perform a sensitivity analysis, using the following meaningful values for the four parameters of MinoanER: $k \\in\\{1,2,3,4,5\\}$ (the number of most distinct predicates per KB whose values serve as names), $K \\in\\{5,10,15,2,25\\}$ (the number of candidate matches per entity from values and neighbors), $N \\in\\{1,2,3,4,5\\}$ (the number of the most important relations per entity), and $\\theta \\in\\{0.3,0.4,0.5,0.6,0.7,0.8\\}$ (the trade-off between value- vs neighbor-based candidates). Preliminary experiments demonstrated that the configuration $(k, K, N, \\theta)=(2,15,3,0.6)$ yields a performance very close to the average one. Therefore, we use these parameter values as the default ones in our sensitivity analysis.\n\nIn more detail, we sequentially vary the values of one parameter, keeping the others fixed to their default value, so as to examine its effect on the overall F1 of MinoanER. The results appear in the diagrams of Figure 5. We observe that MinoanER is quite robust in most cases, as small changes in a parameter value typically lead to an insignificant change in F1. This should be attributed to the composite functionality of MinoanER and its four matching rules,in particular: even if one rule is misconfigured, the other rules make up for the lost matches. There are only two exceptions:\n(i) There is a large increase in F1 over BBCmusic-DBpedia when $k$ increases from 1 to 2 . The former value selects completely different predicates as names for the two KBs, due to the schema heterogeneity of DBpedia, thus eliminating the contribution of the name matching rule to F1. This is ameliorated for $k=2$.\n(ii) F1 is significantly lower over BBCmusic-DBpedia and YAGO-IMDb for $\\theta<0.5$. This should be expected, since Figure\n\nTable 3: Evaluation of MinoanER in comparison to the state-of-the-art methods and the heavily fine-tuned baseline, BSL.\n\n|  |   |   |   |   |   |\n| --- | --- | --- | --- | --- | --- |\n|   |  | Restan- <br> rant | Rexa- <br> DBLP | BBCmusic- <br> DBpedia | YAGO- <br> IMDb  |\n|  SiGMa [21] | Prec. | 99 | 97 | - | 98  |\n|   | Recall | 94 | 90 | - | 85  |\n|   | F1 | 97 | 94 | - | 91  |\n|  LINDA [4] | Prec. | 100 | - | - | -  |\n|   | Recall | 63 | - | - | -  |\n|   | F1 | 77 | - | - | -  |\n|  RiMOM [23] | Prec. | 86 | 80 | - | -  |\n|   | Recall | 77 | 72 | - | -  |\n|   | F1 | 81 | 76 | - | -  |\n|  PARIS [33] | Prec. | 95 | 93.95 | 19.40 | 94  |\n|   | Recall | 88 | 89 | 0.29 | 80  |\n|   | F1 | 91 | 91.41 | 0.51 | 92  |\n|  BSL | Prec. | 100 | 96.57 | 85.20 | 11.68  |\n|   | Recall | 100 | 83.96 | 36.09 | 4.87  |\n|   | F1 | 100 | 89.82 | 50.70 | 6.88  |\n|  MinoanER | Prec. | 100 | 96.74 | 91.44 | 91.02  |\n|   | Recall | 100 | 95.34 | 88.55 | 90.57  |\n|   | F1 | 100 | 96.04 | 89.97 | 90.79  |\n\n2 demonstrates that both datasets are dominated by nearly-similar matches, with the value similarity providing insufficient evidence for detecting them. Hence, $\\theta$ should promote neighbor-similarity at least to the same level as the value-similarity (i.e., $\\theta \\geq 0.5$ ).\n\nAs a result, next, we can exclusively consider the configuration $(k, K, N, \\theta)=(2,15,3,0.6)$ for MinoanER. This is the suggested global configuration that works well over all datasets, but parameter tuning per individual dataset may yield better results.\nComparison with Baselines. Table 3 shows that MinoanER offers competitive performance when matching KBs with few attributes and entity types, despite requiring no domain-specific input. Specifically, it achieves $100 \\%$ F1 in Restaurant, which is $3 \\%$ higher than SiGMa, $9 \\%$ higher than PARIS, and $\\sim 20 \\%$ higher than LINDA and RiMOM. BSL also achieves perfect F1, due to the strongly similar matches (see Figure 2). In Rexa-DBLP, MinoanER also outperforms all existing ER methods. It is $2 \\%$ better than SiGMa in F1, $4.6 \\%$ better than PARIS, $20 \\%$ better than RiMOM, and $6 \\%$ better than BSL. In YAGO-IMDb, MinoanER achieves similar performance to SiGMa ( $91 \\%$ F1), with more identified matches ( $91 \\%$ vs $85 \\%$ ), but lower precision ( $91 \\%$ vs $98 \\%$ ). Compared to PARIS, its F1 is $1 \\%$ lower, due to $3 \\%$ lower precision, despite the $1 \\%$ better recall. The high structural similarity between the two KBs make this dataset a good use case for PARIS. BSL exhibits the worst performance, due to the very low value similarity of matches in this KB. Most importantly, MinoanER achieves the best performance by far over the highly heterogeneous KBs of BBCmusic-DBpedia. PARIS struggles to identify the matches, with BSL performing significantly better, but still poorly in absolute numbers. In contrast, MinoanER succeeds in identifying $89 \\%$ of matches with $91 \\%$ precision, achieving a $90 \\%$ F1.\n\nComparing the performance of MinoanER to that of its input blocks, precision raises by several orders of magnitude at the cost of slightly lower recall. The lower recall is caused by missed\n\nTable 4: Evaluation of matching rules.\n\n|  |  | Restaurant | Rexa- <br> DBLP | BBCmusic- <br> DBpedia | YAGO- <br> IMDb |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| R1 | Precision | 100 | 97.36 | 99.85 | 97.55 |\n|  | Recall | 68.54 | 87.47 | 66.11 | 66.53 |\n|  | F1 | 81.33 | 92.15 | 79.55 | 79.11 |\n| R2 | Precision | 100 | 96.15 | 90.73 | 98.02 |\n|  | Recall | 100 | 70.56 | 37.01 | 69.14 |\n|  | F1 | 100 | 46.38 | 52.66 | 81.08 |\n| R3 | Precision | 98.88 | 94.73 | 81.49 | 90.51 |\n|  | Recall | 98.88 | 94.73 | 81.49 | 90.50 |\n|  | F1 | 98.88 | 94.73 | 81.49 | 90.50 |\n| $-\\mathrm{R} 4$ | Precision | 100 | 96.03 | 89.93 | 90.58 |\n|  | Recall | 100 | 96.03 | 89.93 | 90.57 |\n|  | F1 | 100 | 96.03 | 89.93 | 90.58 |\n| No <br> Neighbors | Precision | 100 | 96.59 | 89.22 | 88.05 |\n|  | Recall | 100 | 95.26 | 85.36 | 87.42 |\n|  | F1 | 100 | 95.92 | 87.25 | 87.73 |\n\nmatches close to the lower left corner of Figure 2, i.e., with very low value and neighbor similarities. This explains why the impact on recall is larger for BBCmusic-DBpedia and YAGO-IMDb.\nEvaluation of Matching Rules. Table 4 summarizes the performance of each matching rule in Algorithm 2, when executed alone, as well as the overall contribution of neighbor similarity evidence.\n\n- Name Matching Rule (R1). This rule achieves both high precision ( $>97 \\%$ ) and a decent recall ( $>66 \\%$ ) in all cases. Hence, given no other matching evidence, R1 alone yields good matching results, emphasizing precision, with only an insignificant number of its suggested matches being false positives. To illustrate the importance of this similarity evidence in real KBs, we have marked the matches with identical names in Figure 2 as bordered points. Thus, we observe that matches may agree on their names, regardless of their value and neighbor similarity evidence.\n- Value Matching Rule (R2). This rule is also very precise ( $>90 \\%$ in all cases), but exhibits a lower recall ( $>30 \\%$ ). Nevertheless, even this low recall is not negligible, especially when it complements the matches found from R1. In the case of strongly similar matches as in Restaurant, this rule alone can identify all the matches with perfect precision.\n- Rank Aggregation Matching Rule (R3). The performance of this rule varies across the four datasets, as it relies on neighborhood evidence. For KBs with low value similarity (left part of Figure 2), this rule is the only solution for finding matches having no/different names. In BBCmusic-DBpedia and YAGO-IMDb, it has the highest contribution in recall and F1 of all matching rules, with the results for YAGO-IMDb being almost equivalent to those of Table 3 (YAGO-IMDb features the lowest value similarities in Figure 2). For KBs with medium value similarity (middle part of Figure 2), but not enough to find matches with R2, aggregating neighbor with value similarity is very effective. In Rexa-DBLP, R3 yields almost perfect results. Overall, R3 is the matching rule with the greatest F1 in 3 out of 4 datasets.\n- Reciprocity Matching Rule (R4). Given that R4 is a filtering rule, i.e., it does not add new results, we measure its contribution by running the full workflow without it. Its performance in Table 4 should be compared to the results in Table 3. This comparison shows that this rule increases the precision of MinoanER, with a small, or no impact on recall. Specifically, it increases the precision of BBCmusic-DBpedia by 1.51\\%, while its recall is decreased by $1.38 \\%$, and in the case of YAGO-IMDb, it improves precision by $0.44 \\%$ with no impact on recall. This results in an increase of $0.04 \\%$ and $0.21 \\%$ in F1. Overall, R4 is the weakest matching rule, yielding only a minor improvement in the results of MinoanER.\n\nContribution of neighbors. To evaluate the contribution of neighbor evidence in the matching results, we have repeated Algorithm 2, without the rule R3. Note that this experiment is not the same as our baseline; here, we use all the other rules, also operating on the pruned disjunctive blocking graph, while the baseline does not use our rules and operates on the unpruned graph. The results show that neighbor evidence plays a minor or even no role in KBs with strongly similar entities, i.e., Restaurant and Rexa-DBLP, while having a bigger impact in KBs with nearly similar matches, i.e., BBCmusic-DBpedia and YAGO-IMDb (see Figure 2). Specifically, compared to the results of Table 3, the use of neighbor evidence improves precision by $2.22 \\%$ and recall by $3.19 \\%$ in BBCmusic-DBpedia, while, in YAGO-IMDB, precision is improved by $2.97 \\%$ and recall by $3.15 \\%$.\nTo evaluate the scalability of matching in MinoanER, we present in Figure 6 the running times and speedup of matching for each dataset, as we change the number of available CPU cores in our cluster, i.e., the number of tasks that can run at the same time. In each diagram, the left vertical axis shows the running time and the right vertical axis shows the speedup, as we increase the number of available cores (from 1 to 72 ) shown in the horizontal axis ${ }^{14}$. Across all experiments, we have kept the same total number of tasks, which was defined as the number of all cores in the cluster multiplied by a parallelism factor of 3 , i.e., 3 tasks are assigned to each core, when all cores are available. This was to ensure that each task would require the same amount of resources (e.g., memory), regardless of the number of available cores.\n\nWe observe that the running times decrease as more cores become available, and this decrease is steeper when using a small number of cores. For example, resolving Rexa-DBLP with 6 cores is 6 times faster than with 1 core, while it is 10 times faster with 12 cores than with 1 core (top-right of Figure 6). We observe a sub-linear speedup in all cases, which is expected when synchronization is required for different steps (see Section 4.1). Though, the bigger datasets have a speedup closer to linear than the smaller ones, because the Spark overhead is smaller with respect to the overall running time in these cases. We have also measured the percentage of time spent for the matching phase (Algorithm 2) compared to the total execution time of MinoanER. In Restaurant and Rexa-DBLP, matching takes $45 \\%$ of the total time, in BBCmusic-DBpedia $30 \\%$ and in YAGO-IMDb $20 \\%$. Thus, in all cases, matching takes less than half the execution time, while it takes smaller percentage of time as the tasks get bigger.\n\nIt is not possible to directly compare the efficiency of MinoanER with the competitive tools of Table 3; most of them are not publicly available, while the available ones do not support parallel execution using Spark. The running times reported in the original works are about sequential algorithms executed in machines with a different setting than ours. However, we can safely argue that our fixed-step process, as opposed to the data-iterative processes of existing works, boosts the efficiency of MinoanER at no cost in (or, in most cases, with even better) effectiveness. Indicatively, the running time of MinoanER for Rexa-DBLP was 3.5 minutes (it took PARIS 11 minutes on one of our cluster's servers - see Experimental Setup - for the same dataset), for BBCmusicDBpedia it was 69 seconds (it took PARIS 3.5 minutes on one of\n\n[^0]\n[^0]:    ${ }^{14}$ We could not run MinoanER on the YAGO-IMDb dataset with only 1 core, due to limited space in a single machine, so we report its running time starting with a minimum of 4 cores. This means that the linear speedup for 72 tasks would not be 72 , but $18(72 / 4)$.\n\n![img-5.jpeg](img-5.jpeg)\n\nFigure 6: Scalability of matching in MinoanER w.r.t. running time (left vertical axis) and speedup (right vertical axis) as more cores are involved.\nour cluster's servers), while the running time for YAGO-IMDb was 28 minutes (SiGMa reports 70 minutes, and PARIS reports 51 hours). In small datasets like Restaurant, MinoanER can be slower than other tools, as Spark has a setup overhead, which is significant for such cases (it took MinoanER 27 seconds to run this dataset, while PARIS needed 6 seconds).\n",
        "title": [
            "## 6 EXPERIMENTAL EVALUATION",
            "### 6.1 Effectiveness Evaluation",
            "### 6.2 Efficiency Evaluation"
        ],
        "summary": "This section presents an extensive experimental evaluation of MinoanER against state-of-the-art entity resolution (ER) tools and a finely tuned baseline, using four diverse benchmark datasets on a Spark-based cluster. The study details experimental setup, dataset characteristics, and various parameter configurations, demonstrating that MinoanER achieves consistently high F1 scores\u2014outperforming or matching existing methods, especially on complex, heterogeneous knowledge bases. Sensitivity analyses reveal that MinoanER is robust to parameter changes, and ablation studies highlight the importance of neighbor-based matching, particularly in challenging datasets. Additionally, scalability experiments show that MinoanER efficiently leverages parallelism for large-scale ER, often providing significant speedups and competitive or superior runtime performance compared to other approaches."
    }
}