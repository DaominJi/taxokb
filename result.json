{"metadata": {"num_papers": 7, "papers_processed": ["LSH Ensemble: Internet-Scale Domain Search", "Auto-Join: Automating Transformation-Based Joins of Tables", "SANTOS (SemANtic Table uniOn Search)", "DeepJoin", "Table Union Search: A New Paradigm for Finding Tables in Open Data", "Starmie: Dataset Discovery from Data Lakes with Table Union Search", "Join Prediction for Automatic Semantic Table Joins"], "generator": "TaskTaxonomyGenerator"}, "problem_definitions": [{"paper_id": "LSH Ensemble: Internet-Scale Domain Search", "problem_formulation": {"simple_description": "\"Given a query domain (a set of values) and a large collection of domains, the goal is to find all domains in the collection that contain a sufficiently large proportion of the query domain, as measured by set containment.\"\n", "formal_definition": {"input": "\"A query domain Q, which is a set of distinct values from an unspecified universe; a collection of domains \ud835\udd07, where each domain is also a set of distinct values; and a threshold t* in [0,1] specifying the minimum required set containment score.\"\n", "output": "\"The set of domains X in \ud835\udd07 such that the set containment score t(Q, X) = |Q \u2229 X| / |Q| is at least t*; that is, all domains in the collection that contain at least a t* fraction of the query domain's values.\""}}}, {"paper_id": "Auto-Join: Automating Transformation-Based Joins of Tables", "problem_formulation": {"simple_description": "\"Given two tables with columns containing semantically related but differently formatted string values, the goal is to automatically generate transformations on one table's columns so that the transformed values can be equi-joined with key columns of the other table.\"\n", "formal_definition": {"input": "\"Two tables, each consisting of rows and columns, where at least one pair of columns (one from each table) are semantically related but may have different string representations; and a predefined set of string-based syntactic operators (such as split, concat, substring, constant, select). No prior knowledge is given about which table is the source or target.\"\n", "output": "\"A transformation, defined as a sequence of string-based syntactic operations from the given operator set, to be applied to columns of one table such that the resulting transformed column can be equi-joined (using string equality) with a key column of the other table, resulting in a 1:1 or N:1 join relationship.\""}}}, {"paper_id": "SANTOS (SemANtic Table uniOn Search)", "problem_formulation": {"simple_description": "\"Given a query table with a specified intent column and a set of data lake tables, the goal is to identify the top-k tables from the data lake that can be unioned with the query table by considering both the semantics of individual columns and the semantics of relationships between columns.\"\n", "formal_definition": {"input": "\"A query table Q with a specified intent column I, and a set of data lake tables T = {T1, T2, ..., Tn}. Each table consists of columns, and for each column and each pair of columns, there may be associated semantic annotations (types or relationships) with confidence scores. The semantic information may be derived from a knowledge base or from the data itself.\"\n", "output": "\"A ranked list of the top-k tables from the data lake that are most unionable with the query table, where unionability is determined by the similarity of both column semantics and relationship semantics between the query table and candidate tables.\""}}}, {"paper_id": "DeepJoin", "problem_formulation": {"simple_description": "\"Given a query column and a repository of columns extracted from a data lake, the goal is to obtain the top-k columns in the repository that are most joinable to the query column, where joinability is defined by either equi-join or semantic-join criteria.\"\n", "formal_definition": {"input": "\"A query column (typically textual, represented as a sequence or set of cell values) and a repository of target columns (also typically textual, each represented as a sequence or set of cell values) extracted from tables in a data lake. The repository excludes columns unlikely to participate in join predicates (e.g., BLOBs). The joinability may be defined for equi-joins (exact value matches) or semantic joins (values with similar meanings). The value of k (the number of top results to return) is also provided.\"\n", "output": "\"A subset of k columns from the repository, ranked in descending order of joinability to the query column, where joinability is measured as the proportion of cells in the query column that have at least one matching cell in a target column, according to the specified join criterion (equi-join or semantic-join).\""}}}, {"paper_id": "Table Union Search: A New Paradigm for Finding Tables in Open Data", "problem_formulation": {"simple_description": "\"Given a query table and a large repository of open data tables, the goal is to identify the top-k tables from the repository that are most likely to be unionable with the query table based on the similarity of their attributes' data domains.\"\n", "formal_definition": {"input": "\"A query table (with one or more attributes and data values) and a large collection of candidate tables (each with their own attributes and data values) from open data repositories. The tables may have missing, ambiguous, or non-informative schemas, and attribute names may not be reliable. No assumption is made about the presence of subject attributes or complete ontologies.\"\n", "output": "\"A ranked list of the top-k tables from the repository that are most likely to be unionable with the query table, where unionability is determined by the degree to which the tables share attributes with values drawn from the same or similar domains.\""}}}, {"paper_id": "Starmie: Dataset Discovery from Data Lakes with Table Union Search", "problem_formulation": {"simple_description": "\"Given a query table and a collection of tables from a data lake, the goal is to identify the top-k tables from the collection that are most unionable with the query table, based on a table unionability score.\"\n", "formal_definition": {"input": "\"A query table S and a collection of tables \ud835\udcaf from a data lake, where each table consists of multiple columns (potentially from different domains). The number of columns and the content of each column may vary across tables.\"\n", "output": "\"A subset \ud835\udcae of k tables from \ud835\udcaf such that, for every table T in \ud835\udcae and every table T' in \ud835\udcaf not in \ud835\udcae, the table unionability score between S and T is greater than or equal to that between S and T'.\""}}}, {"paper_id": "Join Prediction for Automatic Semantic Table Joins", "problem_formulation": {"simple_description": "\"Given two columns of values from different tables, the goal is to determine a mapping from each value in the first column to at most one value in the second column (or to no value), such that the overall semantic correlation between the joined pairs is maximized.\"\n", "formal_definition": {"input": "\"Two columns of values, each represented as a set: R = {r_i} from table 1 and S = {s_j} from table 2. Each column contains values that may represent entities using different formats or codes. The join is restricted to optional many-to-one relationships, where each value in R can be mapped to at most one value in S or to a special non-mapping symbol (\u22a5).\"\n", "output": "\"A mapping (function) J: R \u2192 S \u222a {\u22a5}, assigning to each value in R either a value in S or indicating no mapping (\u22a5), such that the aggregate semantic correlation score (based on co-occurrence statistics from a table corpus) of all joined pairs is maximized.\""}}}], "aspect_classification": {"input_classification": [{}], "output_classification": [{}]}, "taxonomy": {"root": "ROOT", "tasks": [{"name": "TASK:KNOWLEDGE_GRAPH_TASKS", "input": "Knowledge Graph", "output": "Completed Triples", "explanation": "Predict missing edges in a relational graph based on observed triples.", "papers": ["Paper A", "Paper D"]}, {"name": "TASK:RECOMMENDATION_TASKS", "input": "User-Item Interaction Matrix", "output": "Hash Codes", "explanation": "Generate compact binary representations for fast retrieval in recommendation settings.", "papers": ["Paper B", "Paper F"]}, {"name": "TASK:SEQUENCE_BASED_RECOMMENDATION", "input": "Temporal User Interaction Sequence", "output": "Ranked List", "explanation": "Return a ranked set of items based on user behavior sequences.", "papers": ["Paper C", "Paper E"]}, {"name": "TASK:INFORMATION_EXTRACTION_TASKS", "input": "Text Corpus", "output": "Extracted Entities", "explanation": "Identify and extract named entities from unstructured text documents.", "papers": ["Paper G", "Paper H"]}], "hierarchy_text": "---\n---\n---\n- Knowledge Graph Tasks\n  - Knowledge Graph Completion\n- Recommendation Tasks\n  - Hash Code Generation for Retrieval\n  - Sequence-based Recommendation\n- Information Extraction Tasks\n  - Named Entity Recognition\n---\n- ROOT\n  - TASK:L1:KNOWLEDGE_GRAPH_TASKS\n    - TASK:L2:KNOWLEDGE_GRAPH_COMPLETION\n      - Input: Knowledge Graph\n      - Output: Completed Triples\n      - Explanation: Predict missing edges in a relational graph based on observed triples.\n      - Papers: Paper A, Paper D\n  - TASK:L1:RECOMMENDATION_TASKS\n    - TASK:L2:HASH_CODE_GENERATION_FOR_RETRIEVAL\n      - Input: User-Item Interaction Matrix\n      - Output: Hash Codes\n      - Explanation: Generate compact binary representations for fast retrieval in recommendation settings.\n      - Papers: Paper B, Paper F\n    - TASK:L2:SEQUENCE_BASED_RECOMMENDATION\n      - Input: Temporal User Interaction Sequence\n      - Output: Ranked List\n      - Explanation: Return a ranked set of items based on user behavior sequences.\n      - Papers: Paper C, Paper E\n  - TASK:L1:INFORMATION_EXTRACTION_TASKS\n    - TASK:L2:NAMED_ENTITY_RECOGNITION\n      - Input: Text Corpus\n      - Output: Extracted Entities\n      - Explanation: Identify and extract named entities from unstructured text documents.\n      - Papers: Paper G, Paper H\n---\n- The above taxonomy is illustrative, based on typical research task pairings in computer science literature.\n- Actual class names, descriptions, and paper IDs should be filled in from your specific tables and corpus.  \n- The hierarchy can be further refined as more tasks or subtypes are identified."}}